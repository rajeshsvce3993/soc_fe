"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("client_src_App_tsx",{

/***/ "./client/src/lib/api.ts":
/*!*******************************!*\
  !*** ./client/src/lib/api.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alertsApi: function() { return /* binding */ alertsApi; },\n/* harmony export */   authApi: function() { return /* binding */ authApi; },\n/* harmony export */   dashboardApi: function() { return /* binding */ dashboardApi; },\n/* harmony export */   investigationsApi: function() { return /* binding */ investigationsApi; },\n/* harmony export */   rolesApi: function() { return /* binding */ rolesApi; },\n/* harmony export */   usersApi: function() { return /* binding */ usersApi; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\nconst BASE_API_URL = process.env.NEXT_PUBLIC_API_BASE_URL || \"http://127.0.0.1:4000\";\nfunction getToken() {\n    if (false) {}\n    return localStorage.getItem(\"soc_token\");\n}\nfunction authHeaders() {\n    const token = getToken();\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\"\n    };\n    if (token) headers[\"Authorization\"] = \"Bearer \".concat(token);\n    return headers;\n}\nconst authApi = {\n    login: async (email, password)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/signin\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\"\n            },\n            body: JSON.stringify({\n                email,\n                password\n            })\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Auth failed (\".concat(resp.status, \")\"));\n        }\n        const data = await resp.json();\n        return data;\n    },\n    signup: async (payload)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/signup\"), {\n            method: \"POST\",\n            headers: authHeaders(),\n            body: JSON.stringify(payload)\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Signup failed (\".concat(resp.status, \")\"));\n        }\n        return await resp.json();\n    },\n    forgotPassword: async (email)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/forgot-password\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\"\n            },\n            body: JSON.stringify({\n                email\n            })\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Forgot password failed (\".concat(resp.status, \")\"));\n        }\n        try {\n            return await resp.json();\n        } catch (e) {\n            return null;\n        }\n    },\n    sendOtp: async (email)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/send-otp\"), {\n            method: \"POST\",\n            headers: authHeaders(),\n            body: JSON.stringify({\n                email\n            })\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Send OTP failed (\".concat(resp.status, \")\"));\n        }\n        return await resp.json();\n    },\n    verifyOtp: async (email, otp)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/verify-otp\"), {\n            method: \"POST\",\n            headers: authHeaders(),\n            body: JSON.stringify({\n                email,\n                otp\n            })\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Verify OTP failed (\".concat(resp.status, \")\"));\n        }\n        return await resp.json();\n    },\n    updatePassword: async (email, newPassword)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/update-password\"), {\n            method: \"POST\",\n            headers: authHeaders(),\n            body: JSON.stringify({\n                email,\n                newPassword\n            })\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Update password failed (\".concat(resp.status, \")\"));\n        }\n        return await resp.json();\n    }\n};\nconst usersApi = {\n    list: async ()=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/users\"), {\n            headers: authHeaders()\n        });\n        if (!resp.ok) throw new Error(\"Failed to fetch users (\".concat(resp.status, \")\"));\n        const payload = await resp.json();\n        // backend returns { success: true, data: [...] }\n        if (payload && typeof payload === \"object\" && Array.isArray(payload.data)) return payload.data;\n        // fallback: if API returns array directly\n        if (Array.isArray(payload)) return payload;\n        return [];\n    },\n    create: async (payload)=>{\n        // user creation is handled by auth/signup endpoint (requires Authorization header)\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/auth/signup\"), {\n            method: \"POST\",\n            headers: authHeaders(),\n            body: JSON.stringify(payload)\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Create user failed (\".concat(resp.status, \")\"));\n        }\n        return await resp.json();\n    },\n    listOnlyUsers: async ()=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/users/only-users\"), {\n            headers: authHeaders()\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Failed to fetch assignable users (\".concat(resp.status, \")\"));\n        }\n        const payload = await resp.json();\n        if (payload && typeof payload === \"object\" && Array.isArray(payload.data)) return payload.data;\n        if (Array.isArray(payload)) return payload;\n        return [];\n    }\n};\nconst rolesApi = {\n    list: async ()=>{\n        // mock roles endpoint - in future this can fetch from `${BASE_API_URL}/api/roles`\n        await new Promise((r)=>setTimeout(r, 120));\n        return [\n            {\n                value: \"user\",\n                label: \"User\"\n            },\n            {\n                value: \"admin\",\n                label: \"Administrator\"\n            }\n        ];\n    }\n};\nconst dashboardApi = {\n    getMetrics: async ()=>{\n        try {\n            const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/dashboard/getmetrics\"), {\n                headers: authHeaders()\n            });\n            if (!resp.ok) throw new Error(\"Failed to fetch metrics (\".concat(resp.status, \")\"));\n            const payload = await resp.json();\n            // expected shape: { success: true, data: { ...metrics } }\n            if (payload && payload.data) return payload.data;\n            return {};\n        } catch (err) {\n            // fallback to previous mock if backend unavailable\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            return {\n                totalCases: 0,\n                totalCasesTrend: \"0\",\n                openCases: 0,\n                closedCases: 0,\n                mttd: 0,\n                mttr: 0\n            };\n        }\n    },\n    getTrends: async (opts)=>{\n        var _opts_points;\n        const points = (_opts_points = opts === null || opts === void 0 ? void 0 : opts.points) !== null && _opts_points !== void 0 ? _opts_points : 10;\n        var _opts_days;\n        const days = (_opts_days = opts === null || opts === void 0 ? void 0 : opts.days) !== null && _opts_days !== void 0 ? _opts_days : 30;\n        try {\n            const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/dashboard/gettrends?points=\").concat(points, \"&days=\").concat(days), {\n                headers: authHeaders()\n            });\n            if (!resp.ok) throw new Error(\"Failed to fetch trends (\".concat(resp.status, \")\"));\n            const payload = await resp.json();\n            // expected shape: { success: true, data: { series: [...] } }\n            if (payload && payload.data && Array.isArray(payload.data.series)) return payload.data.series;\n            // if API returns array directly\n            if (Array.isArray(payload)) return payload;\n        // fallback to mock generation if no usable data\n        } catch (err) {\n        // ignore and fallback to mock below\n        }\n    // fallback mock\n    // await new Promise((resolve) => setTimeout(resolve, 500));\n    // return Array.from({ length: points }).map((_, i) => ({\n    //   time: `${i * 2}h`,\n    //   mttd: Math.floor(Math.random() * 40) + 10,\n    //   mttr: Math.floor(Math.random() * 60) + 20,\n    // }));\n    },\n    getAccuracyMetrics: async ()=>{\n        try {\n            const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/dashboard/detection-accuracy\"), {\n                headers: authHeaders()\n            });\n            if (!resp.ok) throw new Error(\"Failed to fetch accuracy metrics (\".concat(resp.status, \")\"));\n            const payload = await resp.json();\n            if (payload && payload.data) return payload.data;\n        } catch (err) {\n        // ignore and fallback to mock below\n        }\n    // await new Promise((resolve) => setTimeout(resolve, 500));\n    // return {\n    //   truePositive: { count: 892, percentage: \"71.5%\" },\n    //   falsePositive: { count: 287, percentage: \"23%\" },\n    //   benignPositive: { count: 68, percentage: \"5.5%\" },\n    // };\n    },\n    getRecentActivities: async ()=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/dashboard/recent-activities\"), {\n            headers: authHeaders()\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Failed to fetch recent activities (\".concat(resp.status, \")\"));\n        }\n        const payload = await resp.json();\n        if (payload && Array.isArray(payload.data)) return payload.data;\n        if (Array.isArray(payload)) return payload;\n        return [];\n    }\n};\nconst alertsApi = {\n    getAlerts: async (opts)=>{\n        var _opts_limit;\n        const limit = (_opts_limit = opts === null || opts === void 0 ? void 0 : opts.limit) !== null && _opts_limit !== void 0 ? _opts_limit : 10;\n        var _opts_skip;\n        const skip = (_opts_skip = opts === null || opts === void 0 ? void 0 : opts.skip) !== null && _opts_skip !== void 0 ? _opts_skip : 0;\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/alerts?limit=\").concat(limit, \"&skip=\").concat(skip), {\n            headers: authHeaders()\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Failed to fetch alerts (\".concat(resp.status, \")\"));\n        }\n        const payload = await resp.json();\n        if (payload && typeof payload === \"object\") {\n            const items = Array.isArray(payload.data) ? payload.data : Array.isArray(payload) ? payload : [];\n            return {\n                items,\n                total: typeof payload.total === \"number\" ? payload.total : items.length,\n                limit: typeof payload.limit === \"number\" ? payload.limit : limit,\n                skip: typeof payload.skip === \"number\" ? payload.skip : skip\n            };\n        }\n        // fallback if API returns array directly\n        if (Array.isArray(payload)) {\n            return {\n                items: payload,\n                total: payload.length,\n                limit,\n                skip\n            };\n        }\n        return {\n            items: [],\n            total: 0,\n            limit,\n            skip\n        };\n    },\n    updateAlert: async (id, updates)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/alerts/\").concat(id), {\n            method: \"PATCH\",\n            headers: authHeaders(),\n            body: JSON.stringify(updates)\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Failed to update alert (\".concat(resp.status, \")\"));\n        }\n        return await resp.json();\n    }\n};\nconst investigationsApi = {\n    getTimeline: async (investigationId)=>{\n        const resp = await fetch(\"\".concat(BASE_API_URL, \"/api/investigations/\").concat(investigationId, \"/timeline\"), {\n            headers: authHeaders()\n        });\n        if (!resp.ok) {\n            const text = await resp.text().catch(()=>\"\");\n            throw new Error(text || \"Failed to fetch investigation timeline (\".concat(resp.status, \")\"));\n        }\n        const payload = await resp.json();\n        if (payload && typeof payload === \"object\" && Array.isArray(payload.data)) return payload.data;\n        if (Array.isArray(payload)) return payload;\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixHQUFzQzZELE9BQW5DN0UsY0FBYSx3QkFBc0MsT0FBaEI2RSxpQkFBZ0IsY0FDdEQ7WUFBRXBFLFNBQVNGO1FBQWM7UUFHM0IsSUFBSSxDQUFDUSxLQUFLTSxFQUFFLEVBQUU7WUFDWixNQUFNQyxPQUFPLE1BQU1QLEtBQUtPLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU07WUFDM0MsTUFBTSxJQUFJQyxNQUFNRixRQUFRLDJDQUF1RCxPQUFaUCxLQUFLVSxNQUFNLEVBQUM7UUFDakY7UUFFQSxNQUFNSSxVQUFVLE1BQU1kLEtBQUtZLElBQUk7UUFDL0IsSUFBSUUsV0FBVyxPQUFPQSxZQUFZLFlBQVlTLE1BQU1DLE9BQU8sQ0FBQ1YsUUFBUUgsSUFBSSxHQUFHLE9BQU9HLFFBQVFILElBQUk7UUFDOUYsSUFBSVksTUFBTUMsT0FBTyxDQUFDVixVQUFVLE9BQU9BO1FBQ25DLE9BQU8sRUFBRTtJQUNYO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jbGllbnQvc3JjL2xpYi9hcGkudHM/Y2M0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBCQVNFX0FQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfQkFTRV9VUkwgfHwgXCJodHRwOi8vMTI3LjAuMC4xOjQwMDBcIjtcblxuZnVuY3Rpb24gZ2V0VG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic29jX3Rva2VuXCIpO1xufVxuXG5mdW5jdGlvbiBhdXRoSGVhZGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbigpO1xuICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9O1xuICBpZiAodG9rZW4pIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke3Rva2VufWA7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG5leHBvcnQgY29uc3QgYXV0aEFwaSA9IHtcbiAgbG9naW46IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAke0JBU0VfQVBJX1VSTH0vYXBpL2F1dGgvc2lnbmluYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcC50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBgQXV0aCBmYWlsZWQgKCR7cmVzcC5zdGF0dXN9KWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfSxcblxuICBzaWdudXA6IGFzeW5jIChwYXlsb2FkOiB7IG5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZzsgcGFzc3dvcmQ6IHN0cmluZzsgbW9iaWxlPzogc3RyaW5nOyByb2xlPzogc3RyaW5nIH0pID0+IHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9BUElfVVJMfS9hcGkvYXV0aC9zaWdudXBgLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMoKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcC50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBgU2lnbnVwIGZhaWxlZCAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3AuanNvbigpO1xuICB9LFxuXG4gIGZvcmdvdFBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgJHtCQVNFX0FQSV9VUkx9L2FwaS9hdXRoL2ZvcmdvdC1wYXNzd29yZGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcC50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBgRm9yZ290IHBhc3N3b3JkIGZhaWxlZCAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXNwLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICBzZW5kT3RwOiBhc3luYyAoZW1haWw6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgJHtCQVNFX0FQSV9VUkx9L2FwaS9hdXRoL3NlbmQtb3RwYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcC50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBgU2VuZCBPVFAgZmFpbGVkICgke3Jlc3Auc3RhdHVzfSlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcC5qc29uKCk7XG4gIH0sXG5cbiAgdmVyaWZ5T3RwOiBhc3luYyAoZW1haWw6IHN0cmluZywgb3RwOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9BUElfVVJMfS9hcGkvYXV0aC92ZXJpZnktb3RwYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBvdHAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwLnRleHQoKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0IHx8IGBWZXJpZnkgT1RQIGZhaWxlZCAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3AuanNvbigpO1xuICB9LFxuXG4gIHVwZGF0ZVBhc3N3b3JkOiBhc3luYyAoZW1haWw6IHN0cmluZywgbmV3UGFzc3dvcmQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgJHtCQVNFX0FQSV9VUkx9L2FwaS9hdXRoL3VwZGF0ZS1wYXNzd29yZGAsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCwgbmV3UGFzc3dvcmQgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwLnRleHQoKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0IHx8IGBVcGRhdGUgcGFzc3dvcmQgZmFpbGVkICgke3Jlc3Auc3RhdHVzfSlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgcmVzcC5qc29uKCk7XG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgdXNlcnNBcGkgPSB7XG4gIGxpc3Q6IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgZmV0Y2goYCR7QkFTRV9BUElfVVJMfS9hcGkvdXNlcnNgLCB7XG4gICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgIH0pO1xuICAgIGlmICghcmVzcC5vaykgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdXNlcnMgKCR7cmVzcC5zdGF0dXN9KWApO1xuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCByZXNwLmpzb24oKTtcbiAgICAvLyBiYWNrZW5kIHJldHVybnMgeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBbLi4uXSB9XG4gICAgaWYgKHBheWxvYWQgJiYgdHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCIgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLmRhdGEpKSByZXR1cm4gcGF5bG9hZC5kYXRhO1xuICAgIC8vIGZhbGxiYWNrOiBpZiBBUEkgcmV0dXJucyBhcnJheSBkaXJlY3RseVxuICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSByZXR1cm4gcGF5bG9hZDtcbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGNyZWF0ZTogYXN5bmMgKHBheWxvYWQ6IHsgbmFtZTogc3RyaW5nOyBlbWFpbDogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nOyBtb2JpbGU/OiBzdHJpbmc7IHJvbGU/OiBzdHJpbmcgfSkgPT4ge1xuICAgIC8vIHVzZXIgY3JlYXRpb24gaXMgaGFuZGxlZCBieSBhdXRoL3NpZ251cCBlbmRwb2ludCAocmVxdWlyZXMgQXV0aG9yaXphdGlvbiBoZWFkZXIpXG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAke0JBU0VfQVBJX1VSTH0vYXBpL2F1dGgvc2lnbnVwYCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwLnRleHQoKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0IHx8IGBDcmVhdGUgdXNlciBmYWlsZWQgKCR7cmVzcC5zdGF0dXN9KWApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcC5qc29uKCk7XG4gIH0sXG5cbiAgbGlzdE9ubHlVc2VyczogYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgJHtCQVNFX0FQSV9VUkx9L2FwaS91c2Vycy9vbmx5LXVzZXJzYCwge1xuICAgICAgaGVhZGVyczogYXV0aEhlYWRlcnMoKSxcbiAgICB9KTtcbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwLnRleHQoKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0IHx8IGBGYWlsZWQgdG8gZmV0Y2ggYXNzaWduYWJsZSB1c2VycyAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCByZXNwLmpzb24oKTtcbiAgICBpZiAocGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KHBheWxvYWQuZGF0YSkpIHJldHVybiBwYXlsb2FkLmRhdGE7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHJldHVybiBwYXlsb2FkO1xuICAgIHJldHVybiBbXTtcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCByb2xlc0FwaSA9IHtcbiAgbGlzdDogYXN5bmMgKCkgPT4ge1xuICAgIC8vIG1vY2sgcm9sZXMgZW5kcG9pbnQgLSBpbiBmdXR1cmUgdGhpcyBjYW4gZmV0Y2ggZnJvbSBgJHtCQVNFX0FQSV9VUkx9L2FwaS9yb2xlc2BcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCAxMjApKTtcbiAgICByZXR1cm4gW1xuICAgICAgeyB2YWx1ZTogXCJ1c2VyXCIsIGxhYmVsOiBcIlVzZXJcIiB9LFxuICAgICAgeyB2YWx1ZTogXCJhZG1pblwiLCBsYWJlbDogXCJBZG1pbmlzdHJhdG9yXCIgfVxuICAgIF07XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkYXNoYm9hcmRBcGkgPSB7XG4gIGdldE1ldHJpY3M6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAke0JBU0VfQVBJX1VSTH0vYXBpL2Rhc2hib2FyZC9nZXRtZXRyaWNzYCwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3Aub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG1ldHJpY3MgKCR7cmVzcC5zdGF0dXN9KWApO1xuICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgICAgLy8gZXhwZWN0ZWQgc2hhcGU6IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyAuLi5tZXRyaWNzIH0gfVxuICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5kYXRhKSByZXR1cm4gcGF5bG9hZC5kYXRhO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZmFsbGJhY2sgdG8gcHJldmlvdXMgbW9jayBpZiBiYWNrZW5kIHVuYXZhaWxhYmxlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsQ2FzZXM6IDAsXG4gICAgICAgIHRvdGFsQ2FzZXNUcmVuZDogXCIwXCIsXG4gICAgICAgIG9wZW5DYXNlczogMCxcbiAgICAgICAgY2xvc2VkQ2FzZXM6IDAsXG4gICAgICAgIG10dGQ6IDAsXG4gICAgICAgIG10dHI6IDAsXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgZ2V0VHJlbmRzOiBhc3luYyAob3B0cz86IHsgcG9pbnRzPzogbnVtYmVyOyBkYXlzPzogbnVtYmVyIH0pID0+IHtcbiAgICBjb25zdCBwb2ludHMgPSBvcHRzPy5wb2ludHMgPz8gMTA7XG4gICAgY29uc3QgZGF5cyA9IG9wdHM/LmRheXMgPz8gMzA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgJHtCQVNFX0FQSV9VUkx9L2FwaS9kYXNoYm9hcmQvZ2V0dHJlbmRzP3BvaW50cz0ke3BvaW50c30mZGF5cz0ke2RheXN9YCwge1xuICAgICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3Aub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHRyZW5kcyAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgcmVzcC5qc29uKCk7XG4gICAgICAvLyBleHBlY3RlZCBzaGFwZTogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IHNlcmllczogWy4uLl0gfSB9XG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmRhdGEgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLmRhdGEuc2VyaWVzKSkgcmV0dXJuIHBheWxvYWQuZGF0YS5zZXJpZXM7XG4gICAgICAvLyBpZiBBUEkgcmV0dXJucyBhcnJheSBkaXJlY3RseVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHJldHVybiBwYXlsb2FkO1xuICAgICAgLy8gZmFsbGJhY2sgdG8gbW9jayBnZW5lcmF0aW9uIGlmIG5vIHVzYWJsZSBkYXRhXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZ25vcmUgYW5kIGZhbGxiYWNrIHRvIG1vY2sgYmVsb3dcbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBtb2NrXG4gICAgLy8gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgLy8gcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IHBvaW50cyB9KS5tYXAoKF8sIGkpID0+ICh7XG4gICAgLy8gICB0aW1lOiBgJHtpICogMn1oYCxcbiAgICAvLyAgIG10dGQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQwKSArIDEwLFxuICAgIC8vICAgbXR0cjogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjApICsgMjAsXG4gICAgLy8gfSkpO1xuICB9LFxuICBnZXRBY2N1cmFjeU1ldHJpY3M6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAke0JBU0VfQVBJX1VSTH0vYXBpL2Rhc2hib2FyZC9kZXRlY3Rpb24tYWNjdXJhY3lgLCB7XG4gICAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcC5vaykgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYWNjdXJhY3kgbWV0cmljcyAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgcmVzcC5qc29uKCk7XG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmRhdGEpIHJldHVybiBwYXlsb2FkLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZ25vcmUgYW5kIGZhbGxiYWNrIHRvIG1vY2sgYmVsb3dcbiAgICB9XG5cbiAgICAvLyBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAvLyByZXR1cm4ge1xuICAgIC8vICAgdHJ1ZVBvc2l0aXZlOiB7IGNvdW50OiA4OTIsIHBlcmNlbnRhZ2U6IFwiNzEuNSVcIiB9LFxuICAgIC8vICAgZmFsc2VQb3NpdGl2ZTogeyBjb3VudDogMjg3LCBwZXJjZW50YWdlOiBcIjIzJVwiIH0sXG4gICAgLy8gICBiZW5pZ25Qb3NpdGl2ZTogeyBjb3VudDogNjgsIHBlcmNlbnRhZ2U6IFwiNS41JVwiIH0sXG4gICAgLy8gfTtcbiAgfSxcblxuICBnZXRSZWNlbnRBY3Rpdml0aWVzOiBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAke0JBU0VfQVBJX1VSTH0vYXBpL2Rhc2hib2FyZC9yZWNlbnQtYWN0aXZpdGllc2AsIHtcbiAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcC50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBgRmFpbGVkIHRvIGZldGNoIHJlY2VudCBhY3Rpdml0aWVzICgke3Jlc3Auc3RhdHVzfSlgKTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgIGlmIChwYXlsb2FkICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5kYXRhKSkgcmV0dXJuIHBheWxvYWQuZGF0YTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkgcmV0dXJuIHBheWxvYWQ7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYWxlcnRzQXBpID0ge1xuICBnZXRBbGVydHM6IGFzeW5jIChvcHRzPzogeyBsaW1pdD86IG51bWJlcjsgc2tpcD86IG51bWJlciB9KSA9PiB7XG4gICAgY29uc3QgbGltaXQgPSBvcHRzPy5saW1pdCA/PyAxMDtcbiAgICBjb25zdCBza2lwID0gb3B0cz8uc2tpcCA/PyAwO1xuXG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKGAke0JBU0VfQVBJX1VSTH0vYXBpL2FsZXJ0cz9saW1pdD0ke2xpbWl0fSZza2lwPSR7c2tpcH1gLCB7XG4gICAgICBoZWFkZXJzOiBhdXRoSGVhZGVycygpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwLm9rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcC50ZXh0KCkuY2F0Y2goKCkgPT4gXCJcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBgRmFpbGVkIHRvIGZldGNoIGFsZXJ0cyAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHJlc3AuanNvbigpO1xuXG4gICAgaWYgKHBheWxvYWQgJiYgdHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuaXNBcnJheShwYXlsb2FkLmRhdGEpID8gcGF5bG9hZC5kYXRhIDogQXJyYXkuaXNBcnJheShwYXlsb2FkKSA/IHBheWxvYWQgOiBbXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICB0b3RhbDogdHlwZW9mIHBheWxvYWQudG90YWwgPT09IFwibnVtYmVyXCIgPyBwYXlsb2FkLnRvdGFsIDogaXRlbXMubGVuZ3RoLFxuICAgICAgICBsaW1pdDogdHlwZW9mIHBheWxvYWQubGltaXQgPT09IFwibnVtYmVyXCIgPyBwYXlsb2FkLmxpbWl0IDogbGltaXQsXG4gICAgICAgIHNraXA6IHR5cGVvZiBwYXlsb2FkLnNraXAgPT09IFwibnVtYmVyXCIgPyBwYXlsb2FkLnNraXAgOiBza2lwLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBpZiBBUEkgcmV0dXJucyBhcnJheSBkaXJlY3RseVxuICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtczogcGF5bG9hZCxcbiAgICAgICAgdG90YWw6IHBheWxvYWQubGVuZ3RoLFxuICAgICAgICBsaW1pdCxcbiAgICAgICAgc2tpcCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgaXRlbXM6IFtdLCB0b3RhbDogMCwgbGltaXQsIHNraXAgfTtcbiAgfSxcblxuICB1cGRhdGVBbGVydDogYXN5bmMgKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IGFueSkgPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChgJHtCQVNFX0FQSV9VUkx9L2FwaS9hbGVydHMvJHtpZH1gLCB7XG4gICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgIGhlYWRlcnM6IGF1dGhIZWFkZXJzKCksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVzKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcC5vaykge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3AudGV4dCgpLmNhdGNoKCgpID0+IFwiXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHRleHQgfHwgYEZhaWxlZCB0byB1cGRhdGUgYWxlcnQgKCR7cmVzcC5zdGF0dXN9KWApO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCByZXNwLmpzb24oKTtcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBpbnZlc3RpZ2F0aW9uc0FwaSA9IHtcbiAgZ2V0VGltZWxpbmU6IGFzeW5jIChpbnZlc3RpZ2F0aW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke0JBU0VfQVBJX1VSTH0vYXBpL2ludmVzdGlnYXRpb25zLyR7aW52ZXN0aWdhdGlvbklkfS90aW1lbGluZWAsXG4gICAgICB7IGhlYWRlcnM6IGF1dGhIZWFkZXJzKCkgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwLnRleHQoKS5jYXRjaCgoKSA9PiBcIlwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0IHx8IGBGYWlsZWQgdG8gZmV0Y2ggaW52ZXN0aWdhdGlvbiB0aW1lbGluZSAoJHtyZXNwLnN0YXR1c30pYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IHJlc3AuanNvbigpO1xuICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5kYXRhKSkgcmV0dXJuIHBheWxvYWQuZGF0YTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkgcmV0dXJuIHBheWxvYWQ7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6WyJCQVNFX0FQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0JBU0VfVVJMIiwiZ2V0VG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXV0aEhlYWRlcnMiLCJ0b2tlbiIsImhlYWRlcnMiLCJBY2NlcHQiLCJhdXRoQXBpIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwicmVzcCIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsInRleHQiLCJjYXRjaCIsIkVycm9yIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJzaWdudXAiLCJwYXlsb2FkIiwiZm9yZ290UGFzc3dvcmQiLCJzZW5kT3RwIiwidmVyaWZ5T3RwIiwib3RwIiwidXBkYXRlUGFzc3dvcmQiLCJuZXdQYXNzd29yZCIsInVzZXJzQXBpIiwibGlzdCIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZSIsImxpc3RPbmx5VXNlcnMiLCJyb2xlc0FwaSIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInZhbHVlIiwibGFiZWwiLCJkYXNoYm9hcmRBcGkiLCJnZXRNZXRyaWNzIiwiZXJyIiwicmVzb2x2ZSIsInRvdGFsQ2FzZXMiLCJ0b3RhbENhc2VzVHJlbmQiLCJvcGVuQ2FzZXMiLCJjbG9zZWRDYXNlcyIsIm10dGQiLCJtdHRyIiwiZ2V0VHJlbmRzIiwib3B0cyIsInBvaW50cyIsImRheXMiLCJzZXJpZXMiLCJnZXRBY2N1cmFjeU1ldHJpY3MiLCJnZXRSZWNlbnRBY3Rpdml0aWVzIiwiYWxlcnRzQXBpIiwiZ2V0QWxlcnRzIiwibGltaXQiLCJza2lwIiwiaXRlbXMiLCJ0b3RhbCIsImxlbmd0aCIsInVwZGF0ZUFsZXJ0IiwiaWQiLCJ1cGRhdGVzIiwiaW52ZXN0aWdhdGlvbnNBcGkiLCJnZXRUaW1lbGluZSIsImludmVzdGlnYXRpb25JZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./client/src/lib/api.ts\n"));

/***/ })

});